using System;
using System.Diagnostics;
using System.Numerics;
using System.Security.Cryptography;
using static PKHeX.Core.MemeKeyIndex;

namespace PKHeX.Core;

/// <summary>
/// Key for crypto with <see cref="MemeCrypto"/> binaries.
/// </summary>
public readonly ref struct MemeKey
{
    private readonly ReadOnlySpan<byte> DER;

    /// <summary> Private Exponent, BigInteger </summary>
    private readonly BigInteger D;

    /// <summary> Public Exponent, BigInteger </summary>
    private readonly BigInteger E;

    /// <summary> Modulus, BigInteger </summary>
    private readonly BigInteger N;

    // Constructor
    public MemeKey(MemeKeyIndex key)
    {
        DER = GetMemeDataVerify(key);
        var all = DER;
        N = new BigInteger(all.Slice(0x18, 0x61), isUnsigned: true, isBigEndian: true);
        E = new BigInteger(all.Slice(0x7B, 0x03), isUnsigned: true, isBigEndian: true);

        if (key.CanSign())
            D = new BigInteger(GetMemeDataSign(key), isUnsigned: true, isBigEndian: true);
        else
            D = default;
    }

    /// <summary>
    /// Indicates if this key can be used to resign messages.
    /// </summary>
    public bool CanResign => D != default;

    public const int SignatureLength = 0x60;
    private const int chunk = 0x10;

    /// <summary>
    /// Performs Aes Decryption
    /// </summary>
    internal void AesDecrypt(Span<byte> data)
    {
        var payload = data[..^SignatureLength];
        var sig = data[^SignatureLength..];
        AesDecrypt(payload, sig);
    }

    /// <summary>
    /// Perform Aes Encryption
    /// </summary>
    internal void AesEncrypt(Span<byte> data)
    {
        var payload = data[..^SignatureLength];
        var sig = data[^SignatureLength..];
        AesEncrypt(payload, sig);
    }

    private void AesDecrypt(ReadOnlySpan<byte> data, Span<byte> sig)
    {
        using var aes = GetAesImpl(data);
        Span<byte> temp = stackalloc byte[chunk];
        Span<byte> nextXor = stackalloc byte[chunk];

        for (var i = sig.Length - chunk; i >= 0; i -= chunk)
        {
            var slice = sig.Slice(i, chunk);
            Xor(temp, slice);
            aes.DecryptCbc(temp, aes.IV, temp);
            temp.CopyTo(slice);
        }

        Xor(temp, sig[^chunk..]);
        GetSubKey(temp, nextXor);
        for (var i = 0; i < sig.Length; i += chunk)
            Xor(sig.Slice(i, chunk), nextXor);

        nextXor.Clear();
        for (var i = 0; i < sig.Length; i += chunk)
        {
            var slice = sig.Slice(i, chunk);
            slice.CopyTo(temp);
            aes.DecryptEcb(slice, slice);
            Xor(slice, nextXor);
            temp.CopyTo(nextXor);
        }
    }

    private void AesEncrypt(Span<byte> data, Span<byte> sig)
    {
        using var aes = GetAesImpl(data);
        Span<byte> temp = stackalloc byte[chunk];
        Span<byte> nextXor = stackalloc byte[chunk];

        for (var i = 0; i < sig.Length; i += chunk)
        {
            var slice = sig.Slice(i, chunk);
            Xor(slice, temp);
            aes.EncryptCbc(slice, aes.IV, slice);
            slice.CopyTo(temp);
        }

        Xor(temp, sig[..chunk]);
        GetSubKey(temp, nextXor);
        for (var i = 0; i < sig.Length; i += chunk)
            Xor(sig.Slice(i, chunk), nextXor);

        temp.Clear();
        for (var i = sig.Length - chunk; i >= 0; i -= chunk)
        {
            var slice = sig.Slice(i, chunk);
            slice.CopyTo(nextXor);
            aes.EncryptEcb(slice, slice);
            Xor(slice, temp);
            nextXor.CopyTo(temp);
        }
    }

    private IAesCryptographyProvider.IAes GetAesImpl(ReadOnlySpan<byte> payload)
    {
        // The C# implementation of AES isn't fully allocation-free, so some allocation on key & implementation is needed.
        var key = GetAesKey(payload);

        // Don't dispose in this method, let the consumer dispose.
        // no IV -- all zero.
        var aes = RuntimeCryptographyProvider.Aes.Create(key, CipherMode.CBC, PaddingMode.None);
        aes.IV = new byte[aes.BlockSize / 8]; // Initialize IV to zero for now; will be updated dynamically.
        return aes;
    }

    /// <summary>
    /// Get the AES key for this MemeKey
    /// </summary>
    private byte[] GetAesKey(ReadOnlySpan<byte> data)
    {
        // HashLengthInBytes is 20.
        Span<byte> hash = stackalloc byte[SHA1.HashSizeInBytes];
        using var h = IncrementalHash.CreateHash(HashAlgorithmName.SHA1);
        h.AppendData(DER);
        h.AppendData(data);
        h.GetCurrentHash(hash);
        return hash[..chunk].ToArray(); // need a byte[0x10] (not 0x14) for the AES impl
    }

    private static void GetSubKey(ReadOnlySpan<byte> temp, Span<byte> subkey)
    {
        for (var i = 0; i < temp.Length; i += 2) // Imperfect ROL implementation
        {
            byte b1 = temp[i + 0], b2 = temp[i + 1];
            subkey[i + 0] = (byte)((2 * b1) + (b2 >> 7));
            subkey[i + 1] = (byte)(2 * b2);
            if (i + 2 < temp.Length)
                subkey[i + 1] += (byte)(temp[i + 2] >> 7);
        }
        if ((temp[0] & 0x80) != 0)
            subkey[0xF] ^= 0x87;
    }

    private static void Xor(Span<byte> b1, Span<byte> b2)
    {
        Debug.Assert(b1.Length <= b2.Length);
        for (var i = 0; i < b2.Length; i++)
            b1[i] ^= b2[i];
    }

    /// <summary>
    /// Perform Rsa Decryption
    /// </summary>
    internal void RsaPrivate(ReadOnlySpan<byte> data, Span<byte> outSig)
    {
        var M = new BigInteger(data, isUnsigned: true, isBigEndian: true);
        Exponentiate(M, D, outSig);
    }

    /// <summary>
    /// Perform Rsa Encryption
    /// </summary>
    internal void RsaPublic(ReadOnlySpan<byte> data, Span<byte> outSig)
    {
        var M = new BigInteger(data, isUnsigned: true, isBigEndian: true);
        Exponentiate(M, E, outSig);
    }

    #region MemeKey Helper Methods

    // Helper method for Modular Exponentiation
    private void Exponentiate(BigInteger M, BigInteger Power, Span<byte> result)
    {
        var raw = BigInteger.ModPow(M, Power, N);
        raw.TryWriteBytes(result, out _, isUnsigned: true, isBigEndian: true);
    }

    private static ReadOnlySpan<byte> GetMemeDataVerify(MemeKeyIndex key) => key switch
    {
        LocalWireless           => DER_LW,
        FriendlyCompetition     => DER_0,
        LiveCompetition         => DER_1,
        RentalTeam              => DER_2,
        PokedexAndSaveFile      => DER_3,
        GaOle                   => DER_4,
        MagearnaEvent           => DER_5,
        MoncolleGet             => DER_6,
        IslandScanEventSpecial  => DER_7,
        TvTokyoDataBroadcasting => DER_8,
        CapPikachuEvent         => DER_9,
        Unknown10               => DER_A,
        Unknown11               => DER_B,
        Unknown12               => DER_C,
        Unknown13               => DER_D,
        _ => throw new ArgumentOutOfRangeException(nameof(key), key, null),
    };

    private static ReadOnlySpan<byte> GetMemeDataSign(MemeKeyIndex key) => key switch
    {
        PokedexAndSaveFile => D_3,
        _ => throw new ArgumentOutOfRangeException(nameof(key), key, null),
    };

    public static bool IsValidPokeKeyIndex(int index)
    {
        if (!Enum.IsDefined(typeof(MemeKeyIndex), index))
            return false;
        return (MemeKeyIndex)index != LocalWireless;
    }
    #endregion

    #region Official Keydata
    private static ReadOnlySpan<byte> DER_LW=> [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xB7, 0x56, 0xE1, 0xDC, 0xD8, 0xCE, 0xCE, 0x78, 0xE1, 0x48, 0x10, 0x7B, 0x1B, 0xAC, 0x11, 0x5F, 0xDB, 0x17, 0xDE, 0x84, 0x34, 0x53, 0xCA, 0xB7, 0xD4, 0xE6, 0xDF, 0x8D, 0xD2, 0x1F, 0x5A, 0x3D, 0x17, 0xB4, 0x47, 0x7A, 0x8A, 0x53, 0x1D, 0x97, 0xD5, 0x7E, 0xB5, 0x58, 0xF0, 0xD5, 0x8A, 0x4A, 0xF5, 0xBF, 0xAD, 0xDD, 0xA4, 0xA0, 0xBC, 0x1D, 0xC2, 0x2F, 0xF8, 0x75, 0x76, 0xC7, 0x26, 0x8B, 0x94, 0x28, 0x19, 0xD4, 0xC8, 0x3F, 0x78, 0xE1, 0xEE, 0x92, 0xD4, 0x06, 0x66, 0x2F, 0x4E, 0x68, 0x47, 0x1E, 0x4D, 0xE8, 0x33, 0xE5, 0x12, 0x6C, 0x32, 0xEB, 0x63, 0xA8, 0x68, 0x34, 0x5D, 0x1D, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_0 => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xB3, 0xD6, 0x8C, 0x9B, 0x10, 0x90, 0xF6, 0xB1, 0xB8, 0x8E, 0xCF, 0xA9, 0xE2, 0xF6, 0x0E, 0x9C, 0x62, 0xC3, 0x03, 0x3B, 0x5B, 0x64, 0x28, 0x2F, 0x26, 0x2C, 0xD3, 0x93, 0xB4, 0x33, 0xD9, 0x7B, 0xD3, 0xDB, 0x7E, 0xBA, 0x47, 0x0B, 0x1A, 0x77, 0xA3, 0xDB, 0x3C, 0x18, 0xA1, 0xE7, 0x61, 0x69, 0x72, 0x22, 0x9B, 0xDA, 0xD5, 0x4F, 0xB0, 0x2A, 0x19, 0x54, 0x6C, 0x65, 0xFA, 0x47, 0x73, 0xAA, 0xBE, 0x9B, 0x8C, 0x92, 0x67, 0x07, 0xE7, 0xB7, 0xDD, 0xE4, 0xC8, 0x67, 0xC0, 0x1C, 0x08, 0x02, 0x98, 0x5E, 0x43, 0x86, 0x56, 0x16, 0x8A, 0x44, 0x30, 0xF3, 0xF3, 0xB9, 0x66, 0x2D, 0x7D, 0x01, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_1 => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xC1, 0x0F, 0x40, 0x97, 0xFD, 0x3C, 0x78, 0x1A, 0x8F, 0xDE, 0x10, 0x1E, 0xF3, 0xB2, 0xF0, 0x91, 0xF8, 0x2B, 0xEE, 0x47, 0x42, 0x32, 0x4B, 0x92, 0x06, 0xC5, 0x81, 0x76, 0x6E, 0xAF, 0x2F, 0xBB, 0x42, 0xC7, 0xD6, 0x0D, 0x74, 0x9B, 0x99, 0x9C, 0x52, 0x9B, 0x0E, 0x22, 0xAD, 0x05, 0xE0, 0xC8, 0x80, 0x23, 0x12, 0x19, 0xAD, 0x47, 0x31, 0x14, 0xEC, 0x45, 0x43, 0x80, 0xA9, 0x28, 0x98, 0xD7, 0xA8, 0xB5, 0x4D, 0x94, 0x32, 0x58, 0x48, 0x97, 0xD6, 0xAF, 0xE4, 0x86, 0x02, 0x35, 0x12, 0x61, 0x90, 0xA3, 0x28, 0xDD, 0x65, 0x25, 0xD9, 0x7B, 0x90, 0x58, 0xD9, 0x86, 0x40, 0xB0, 0xFA, 0x05, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_2 => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xC3, 0xC8, 0xD8, 0x9F, 0x55, 0xD6, 0xA2, 0x36, 0xA1, 0x15, 0xC7, 0x75, 0x94, 0xD4, 0xB3, 0x18, 0xF0, 0xA0, 0xA0, 0xE3, 0x25, 0x2C, 0xC0, 0xD6, 0x34, 0x5E, 0xB9, 0xE3, 0x3A, 0x43, 0xA5, 0xA5, 0x6D, 0xC9, 0xD1, 0x0B, 0x7B, 0x59, 0xC1, 0x35, 0x39, 0x61, 0x59, 0xEC, 0x4D, 0x01, 0xDE, 0xBC, 0x5F, 0xB3, 0xA4, 0xCA, 0xE4, 0x78, 0x53, 0xE2, 0x05, 0xFE, 0x08, 0x98, 0x2D, 0xFC, 0xC0, 0xC3, 0x9F, 0x05, 0x57, 0x44, 0x9F, 0x97, 0xD4, 0x1F, 0xED, 0x13, 0xB8, 0x86, 0xAE, 0xBE, 0xEA, 0x91, 0x8F, 0x47, 0x67, 0xE8, 0xFB, 0xE0, 0x49, 0x4F, 0xFF, 0x6F, 0x6E, 0xE3, 0x50, 0x8E, 0x3A, 0x3F, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_3 => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xB6, 0x1E, 0x19, 0x20, 0x91, 0xF9, 0x0A, 0x8F, 0x76, 0xA6, 0xEA, 0xAA, 0x9A, 0x3C, 0xE5, 0x8C, 0x86, 0x3F, 0x39, 0xAE, 0x25, 0x3F, 0x03, 0x78, 0x16, 0xF5, 0x97, 0x58, 0x54, 0xE0, 0x7A, 0x9A, 0x45, 0x66, 0x01, 0xE7, 0xC9, 0x4C, 0x29, 0x75, 0x9F, 0xE1, 0x55, 0xC0, 0x64, 0xED, 0xDF, 0xA1, 0x11, 0x44, 0x3F, 0x81, 0xEF, 0x1A, 0x42, 0x8C, 0xF6, 0xCD, 0x32, 0xF9, 0xDA, 0xC9, 0xD4, 0x8E, 0x94, 0xCF, 0xB3, 0xF6, 0x90, 0x12, 0x0E, 0x8E, 0x6B, 0x91, 0x11, 0xAD, 0xDA, 0xF1, 0x1E, 0x7C, 0x96, 0x20, 0x8C, 0x37, 0xC0, 0x14, 0x3F, 0xF2, 0xBF, 0x3D, 0x7E, 0x83, 0x11, 0x41, 0xA9, 0x73, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_4 => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xA0, 0xF2, 0xAC, 0x80, 0xB4, 0x08, 0xE2, 0xE4, 0xD5, 0x89, 0x16, 0xA1, 0xC7, 0x06, 0xBE, 0xE7, 0xA2, 0x47, 0x58, 0xA6, 0x2C, 0xE9, 0xB5, 0x0A, 0xF1, 0xB3, 0x14, 0x09, 0xDF, 0xCB, 0x38, 0x2E, 0x88, 0x5A, 0xA8, 0xBB, 0x8C, 0x0E, 0x4A, 0xD1, 0xBC, 0xF6, 0xFF, 0x64, 0xFB, 0x30, 0x37, 0x75, 0x7D, 0x2B, 0xEA, 0x10, 0xE4, 0xFE, 0x90, 0x07, 0xC8, 0x50, 0xFF, 0xDC, 0xF7, 0x0D, 0x2A, 0xFA, 0xA4, 0xC5, 0x3F, 0xAF, 0xE3, 0x8A, 0x99, 0x17, 0xD4, 0x67, 0x86, 0x2F, 0x50, 0xFE, 0x37, 0x59, 0x27, 0xEC, 0xFE, 0xF4, 0x33, 0xE6, 0x1B, 0xF8, 0x17, 0xA6, 0x45, 0xFA, 0x56, 0x65, 0xD9, 0xCF, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_5 => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xD0, 0x46, 0xF2, 0x87, 0x28, 0x68, 0xA5, 0x08, 0x92, 0x05, 0xB2, 0x26, 0xDE, 0x13, 0xD8, 0x6D, 0xA5, 0x52, 0x64, 0x6A, 0xC1, 0x52, 0xC8, 0x46, 0x15, 0xBE, 0x8E, 0x0A, 0x58, 0x97, 0xC3, 0xEA, 0x45, 0x87, 0x10, 0x28, 0xF4, 0x51, 0x86, 0x0E, 0xA2, 0x26, 0xD5, 0x3B, 0x68, 0xDD, 0xD5, 0xA7, 0x7D, 0x1A, 0xD8, 0x2F, 0xAF, 0x85, 0x7E, 0xA5, 0x2C, 0xF7, 0x93, 0x31, 0x12, 0xEE, 0xC3, 0x67, 0xA0, 0x6C, 0x07, 0x61, 0xE5, 0x80, 0xD3, 0xD7, 0x0B, 0x6B, 0x9C, 0x83, 0x7B, 0xAA, 0x3F, 0x16, 0xD1, 0xFF, 0x7A, 0xA2, 0x0D, 0x87, 0xA2, 0xA5, 0xE2, 0xBC, 0xC6, 0xE3, 0x83, 0xBF, 0x12, 0xD5, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_6 => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xD3, 0x79, 0x91, 0x90, 0x01, 0xD7, 0xFF, 0x40, 0xAC, 0x59, 0xDF, 0x47, 0x5C, 0xF6, 0xC6, 0x36, 0x8B, 0x19, 0x58, 0xDD, 0x4E, 0x87, 0x0D, 0xFD, 0x1C, 0xE1, 0x12, 0x18, 0xD5, 0xEA, 0x9D, 0x88, 0xDD, 0x7A, 0xD5, 0x30, 0xE2, 0x80, 0x6B, 0x0B, 0x09, 0x2C, 0x02, 0xE2, 0x5D, 0xB0, 0x92, 0x51, 0x89, 0x08, 0xED, 0xA5, 0x74, 0xA0, 0x96, 0x8D, 0x49, 0xB0, 0x50, 0x39, 0x54, 0xB2, 0x42, 0x84, 0xFA, 0x75, 0x44, 0x5A, 0x07, 0x4C, 0xE6, 0xE1, 0xAB, 0xCE, 0xC8, 0xFD, 0x01, 0xDA, 0xA0, 0xD2, 0x1A, 0x0D, 0xD9, 0x7B, 0x41, 0x7B, 0xC3, 0xE5, 0x4B, 0xEB, 0x72, 0x53, 0xFC, 0x06, 0xD3, 0xF3, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_7 => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xB7, 0x51, 0xCB, 0x7D, 0x28, 0x26, 0x25, 0xF2, 0x96, 0x1A, 0x71, 0x38, 0x65, 0x0A, 0xBE, 0x1A, 0x6A, 0xA8, 0x0D, 0x69, 0x54, 0x8B, 0xA3, 0xAE, 0x9D, 0xFF, 0x06, 0x5B, 0x28, 0x05, 0xEB, 0x36, 0x75, 0xD9, 0x60, 0xC6, 0x20, 0x96, 0xC2, 0x83, 0x5B, 0x1D, 0xF1, 0xC2, 0x90, 0xFC, 0x19, 0x41, 0x19, 0x44, 0xAF, 0xDF, 0x34, 0x58, 0xE3, 0xB1, 0xBC, 0x81, 0xA9, 0x8C, 0x3F, 0x3E, 0x95, 0xD0, 0xEE, 0x0C, 0x20, 0xA0, 0x25, 0x9E, 0x61, 0x43, 0x99, 0x40, 0x43, 0x54, 0xD9, 0x0F, 0x0C, 0x69, 0x11, 0x1A, 0x4E, 0x52, 0x5F, 0x42, 0x5F, 0xBB, 0x31, 0xA3, 0x8B, 0x8C, 0x55, 0x8F, 0x23, 0x73, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_8 => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xB3, 0x28, 0xFE, 0x4C, 0xC4, 0x16, 0x27, 0x88, 0x2B, 0x04, 0xFB, 0xA0, 0xA3, 0x96, 0xA1, 0x52, 0x85, 0xA8, 0x56, 0x4B, 0x61, 0x12, 0xC1, 0x20, 0x30, 0x48, 0x76, 0x6D, 0x82, 0x7E, 0x8E, 0x4E, 0x56, 0x55, 0xD4, 0x4B, 0x26, 0x6B, 0x28, 0x36, 0x57, 0x5A, 0xE6, 0x8C, 0x83, 0x01, 0x63, 0x2A, 0x3E, 0x58, 0xB1, 0xF4, 0x36, 0x21, 0x31, 0xE9, 0x7B, 0x0A, 0xA0, 0xAF, 0xC3, 0x8F, 0x2F, 0x76, 0x90, 0xCB, 0xD4, 0xF3, 0xF4, 0x65, 0x20, 0x72, 0xBF, 0xD8, 0xE9, 0x42, 0x1D, 0x2B, 0xEE, 0xF1, 0x77, 0x87, 0x3C, 0xD7, 0xD0, 0x8B, 0x6C, 0x0D, 0x10, 0x22, 0x10, 0x9C, 0xA3, 0xED, 0x5B, 0x63, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_9 => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xC4, 0xB3, 0x2F, 0xD1, 0x16, 0x1C, 0xC3, 0x0D, 0x04, 0xBD, 0x56, 0x9F, 0x40, 0x9E, 0x87, 0x8A, 0xA2, 0x81, 0x5C, 0x91, 0xDD, 0x00, 0x9A, 0x5A, 0xE8, 0xBF, 0xDA, 0xEA, 0x7D, 0x11, 0x6B, 0xF2, 0x49, 0x66, 0xBF, 0x10, 0xFC, 0xC0, 0x01, 0x4B, 0x25, 0x8D, 0xFE, 0xF6, 0x61, 0x4E, 0x55, 0xFB, 0x6D, 0xAB, 0x23, 0x57, 0xCD, 0x6D, 0xF5, 0xB6, 0x3A, 0x5F, 0x05, 0x9F, 0x72, 0x44, 0x69, 0xC0, 0x17, 0x8D, 0x83, 0xF8, 0x8F, 0x45, 0x04, 0x89, 0x82, 0xEA, 0xE7, 0xA7, 0xCC, 0x24, 0x9F, 0x84, 0x66, 0x7F, 0xC3, 0x93, 0x68, 0x4D, 0xA5, 0xEF, 0xE1, 0x85, 0x6E, 0xB1, 0x00, 0x27, 0xD1, 0xD7, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_A => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xC5, 0xB7, 0x54, 0x01, 0xE8, 0x33, 0x52, 0xA6, 0x4E, 0xEC, 0x89, 0x16, 0xC4, 0x20, 0x6F, 0x17, 0xEC, 0x33, 0x8A, 0x24, 0xA6, 0xF7, 0xFD, 0x51, 0x52, 0x60, 0x69, 0x6D, 0x72, 0x28, 0x49, 0x6A, 0xBC, 0x14, 0x23, 0xE1, 0xFF, 0x30, 0x51, 0x41, 0x49, 0xFC, 0x19, 0x97, 0x20, 0xE9, 0x5E, 0x68, 0x25, 0x39, 0x89, 0x2E, 0x51, 0x0B, 0x23, 0x9A, 0x8C, 0x7A, 0x41, 0x3D, 0xE4, 0xEE, 0xE7, 0x45, 0x94, 0xF0, 0x73, 0x81, 0x5E, 0x9B, 0x43, 0x47, 0x11, 0xF6, 0x80, 0x7E, 0x8B, 0x9E, 0x7C, 0x10, 0xC2, 0x81, 0xF8, 0x9C, 0xF3, 0xB1, 0xC1, 0x4E, 0x3F, 0x0A, 0xDF, 0x83, 0xA2, 0x80, 0x5F, 0x09, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_B => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xAC, 0x36, 0xB8, 0x8D, 0x00, 0xC3, 0x99, 0xC6, 0x60, 0xB4, 0x84, 0x62, 0x87, 0xFF, 0xC7, 0xF9, 0xDF, 0x5C, 0x07, 0x48, 0x7E, 0xAA, 0xE3, 0xCD, 0x4E, 0xFD, 0x00, 0x29, 0xD3, 0xB8, 0x6E, 0xD3, 0x65, 0x8A, 0xD7, 0xDE, 0xE4, 0xC7, 0xF5, 0xDA, 0x25, 0xF9, 0xF6, 0x00, 0x88, 0x85, 0xF3, 0x43, 0x12, 0x22, 0x74, 0x99, 0x4C, 0xAB, 0x64, 0x77, 0x76, 0xF0, 0xAD, 0xCF, 0xBA, 0x1E, 0x0E, 0xCE, 0xC8, 0xBF, 0x57, 0xCA, 0xAB, 0x84, 0x88, 0xBD, 0xD5, 0x9A, 0x55, 0x19, 0x5A, 0x01, 0x67, 0xC7, 0xD2, 0xC4, 0xA9, 0xCF, 0x67, 0x9D, 0x0E, 0xFF, 0x4A, 0x62, 0xB5, 0xC8, 0x56, 0x8E, 0x09, 0x77, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_C => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xCA, 0xC0, 0x51, 0x4D, 0x4B, 0x6A, 0x3F, 0x70, 0x77, 0x1C, 0x46, 0x1B, 0x01, 0xBD, 0xE3, 0xB6, 0xD4, 0x7A, 0x0A, 0xDA, 0x07, 0x80, 0x74, 0xDD, 0xA5, 0x07, 0x03, 0xD8, 0xCC, 0x28, 0x08, 0x93, 0x79, 0xDA, 0x64, 0xFB, 0x3A, 0x34, 0xAD, 0x34, 0x35, 0xD2, 0x4F, 0x73, 0x31, 0x38, 0x3B, 0xDA, 0xDC, 0x48, 0x77, 0x66, 0x2E, 0xFB, 0x55, 0x5D, 0xA2, 0x07, 0x76, 0x19, 0xB7, 0x0A, 0xB0, 0x34, 0x2E, 0xBE, 0x6E, 0xE8, 0x88, 0xEB, 0xF3, 0xCF, 0x4B, 0x7E, 0x8B, 0xCC, 0xA9, 0x5C, 0x61, 0xE9, 0x93, 0xBD, 0xD6, 0x10, 0x4C, 0x10, 0xD1, 0x11, 0x15, 0xDC, 0x84, 0x17, 0x8A, 0x58, 0x94, 0x35, 0x02, 0x03, 0x01, 0x00, 0x01 ];
    private static ReadOnlySpan<byte> DER_D => [ 0x30, 0x7C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x6B, 0x00, 0x30, 0x68, 0x02, 0x61, 0x00, 0xB9, 0x06, 0x46, 0x67, 0x40, 0xF5, 0xA9, 0x42, 0x8D, 0xA8, 0x4B, 0x41, 0x8C, 0x7F, 0xA6, 0x14, 0x6F, 0x7E, 0x24, 0xC7, 0x83, 0x37, 0x3D, 0x67, 0x1F, 0x92, 0x14, 0xB4, 0x09, 0x48, 0xA4, 0xA3, 0x17, 0xC1, 0xA4, 0x46, 0x01, 0x11, 0xB4, 0x5D, 0x2D, 0xAD, 0xD0, 0x93, 0x81, 0x54, 0x01, 0x57, 0x3E, 0x52, 0xF0, 0x17, 0x88, 0x90, 0xD3, 0x5C, 0xBD, 0x95, 0x71, 0x2E, 0xFA, 0xAE, 0x0D, 0x20, 0xAD, 0x47, 0x18, 0x76, 0x48, 0x77, 0x5C, 0xD9, 0x56, 0x94, 0x31, 0xB1, 0xFC, 0x3C, 0x78, 0x41, 0x13, 0xE3, 0xA4, 0x84, 0x36, 0xD3, 0x0B, 0x2C, 0xD1, 0x62, 0x21, 0x8D, 0x67, 0x81, 0xF5, 0xED, 0x02, 0x03, 0x01, 0x00, 0x01 ];

    // Signing Keys
    private static ReadOnlySpan<byte> D_3   => [ 0x00, 0x77, 0x54, 0x55, 0x66, 0x8F, 0xFF, 0x3C, 0xBA, 0x30, 0x26, 0xC2, 0xD0, 0xB2, 0x6B, 0x80, 0x85, 0x89, 0x59, 0x58, 0x34, 0x11, 0x57, 0xAE, 0xB0, 0x3B, 0x6B, 0x04, 0x95, 0xEE, 0x57, 0x80, 0x3E, 0x21, 0x86, 0xEB, 0x6C, 0xB2, 0xEB, 0x62, 0xA7, 0x1D, 0xF1, 0x8A, 0x3C, 0x9C, 0x65, 0x79, 0x07, 0x76, 0x70, 0x96, 0x1B, 0x3A, 0x61, 0x02, 0xDA, 0xBE, 0x5A, 0x19, 0x4A, 0xB5, 0x8C, 0x32, 0x50, 0xAE, 0xD5, 0x97, 0xFC, 0x78, 0x97, 0x8A, 0x32, 0x6D, 0xB1, 0xD7, 0xB2, 0x8D, 0xCC, 0xCB, 0x2A, 0x3E, 0x01, 0x4E, 0xDB, 0xD3, 0x97, 0xAD, 0x33, 0xB8, 0xF2, 0x8C, 0xD5, 0x25, 0x05, 0x42, 0x51 ];
    #endregion
}
